

#if 0

T-Max has to fix it. Or better make it a standalone program

/* Stdlib includes: */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>
/* CoD4X includes: */
#include "extractor.h"
#include "../zlib/unzip.h"
#include "../q_shared.h"
#include "../cmd.h"
#include "../qcommon_io.h"
#include "../sys_main.h"
#include "../filesystem.h"
#include "../qcommon.h"
#include "../xassets.h"
/* Assets includes: */
#include "rawfile.h"
#include "localized.h"
#include "stringtable.h"
#include "menulist.h"
#include "menu.h"

#define MAX_STORE_FASTFILES (32)
#define ACTION_OPTIMIZER_BUFFER_SIZE (2560)
#define MAX_LOCSTRING_FILES (32)
#define WRITE_EXTRACTOR_HEADER(file_handle) \
    do { \
        FS_Write("// This file has been autogenerated using CoD4X 1.8 server. //\n", 63, (file_handle)); \
        FS_Write("// If it contains wrong data, please create issue here:     //\n", 63, (file_handle)); \
        FS_Write("//    https://github.com/callofduty4x/CoD4x_Server/issues   //\n", 63, (file_handle)); \
    } while(0)

typedef unsigned char byte_t;
typedef unsigned int uint;
typedef void(*extract_routine_t)(const char*);

typedef struct AssetHandler_t
{
    int type;
    void *header;
} AssetHandler_t;

typedef struct FastFileContents_t
{
    int str_list_count;
    char *str_list_data;
    int asset_list_count;
    AssetHandler_t *asset_list_data;
} FastFileContents_t;

typedef struct ZoneDataBlock_t
{
    byte_t *data;
    uint size;
} ZoneDataBlock_t;

/* This struct is the T-Max version of DB_LoadData */
typedef struct FastFileZlibHandler_t
{
    FILE *fd;
    char *name;
    ZoneDataBlock_t *pBlocks;
    int avail_in;
    z_stream strm;
    int *next_in;
    int field_48;
    int (*funcUnk)(void);
    int pad2;
} FastFileZlibHandler_t;

typedef struct ExtractorAssetHandler_t
{
    int type;
    const char *name;
    extract_routine_t handler;
} ExtractorAssetHandler_t;

/*
#define g_pFFContents (*(FastFileContents_t **)0x1411F540)
*/
extern FastFileZlibHandler_t g_load;


static void extract_rawfile(const void *header);
static void extract_menufile(const void *header);
static void extract_stringtable(const void *header);
static void extract_localized_string(const void *header);

typedef struct FastFileAssetsTableInfo_t
{
    char name[64];
    FastFileContents_t content;
} FastFileAssetsTableInfo_t;

static FastFileAssetsTableInfo_t g_FastFileAssetsTableInfo[MAX_STORE_FASTFILES];
static char g_savePath[MAX_OSPATH];
static char *g_zone_name;
static char g_LocalizedStringFiles[MAX_LOCSTRING_FILES][MAX_OSPATH];
static uint g_LocalizedStringFilesCount = 0;
static const ExtractorAssetHandler_t g_ExtractorRoutines[33] = {
    {0, 0, 0},
    {1, 0, 0},
    {2, 0, 0},
    {3, 0, 0},
    {4, 0, 0},
    {5, 0, 0},
    {6, 0, 0},
    {7, 0, 0},
    {8, 0, 0},
    {9, 0, 0},
    {10, 0, 0},
    {11, 0, 0},
    {12, 0, 0},
    {13, 0, 0},
    {14, 0, 0},
    {15, 0, 0},
    {16, 0, 0},
    {17, 0, 0},
    {18, 0, 0},
    {19, 0, 0},
    {ASSET_TYPE_MENULIST, "menufile", (extract_routine_t)extract_menufile},
    {21, 0},
    {ASSET_TYPE_LOCALIZE_ENTRY, "localizedstring", (extract_routine_t)extract_localized_string},
    {23, 0},
    {24, 0},
    {25, 0},
    {26, 0},
    {27, 0},
    {28, 0},
    {29, 0},
    {30, 0},
    {ASSET_TYPE_RAWFILE, "rawfile", (extract_routine_t)extract_rawfile},
    {ASSET_TYPE_STRINGTABLE, "stringtable", (extract_routine_t)extract_stringtable}
};

/* Setups output path. */
void extractor_init()
{
    time_t t = time(0);
    struct tm *local = localtime(&t);
    snprintf(g_savePath, MAX_OSPATH, "extracted/%04d-%02d-%02d_%02d-%02d-%02d/",
            local->tm_year + 1900, local->tm_mon + 1, local->tm_mday,
            local->tm_hour, local->tm_min, local->tm_sec);
}

/* First MAX_STORE_FASTFILES will be saved. Others will replace last one.
   Be careful with fastfiles which can be unloaded. */
void store_fastfile_contents_information()
{
    int i;
    FastFileAssetsTableInfo_t *info;

    /* Do not add maps to this list as they can be unloaded 
       and unloading not covered by this code. */
    if (!strncmp(g_load.name, "mp_", 3))
        return;

    for (i = 0; i < MAX_STORE_FASTFILES; ++i)
    {
        info = &g_FastFileAssetsTableInfo[i];
        if (!strcmp(info->name, g_load.name) || !info->name[0])
            break;
    }
    /* 'info' points to old fastfile or to place for new one. */
    Com_Memset(info, 0, sizeof(FastFileAssetsTableInfo_t));
    strcpy(info->name, g_load.name);
    Com_Memcpy(&info->content, g_pFFContents, sizeof(FastFileContents_t));
}

/* Adds a line to zone_source file which can be used by linker_pc. */
static void add_zone_source_line(const char *asset_type, const char *asset_name)
{
    fileHandle_t zone_source;
    char zone_source_path[MAX_OSPATH] = {'\0'};

    snprintf(zone_source_path, MAX_OSPATH, "%s%s/zone_source/%s.csv", g_savePath, g_zone_name, g_zone_name);
    zone_source = FS_SV_FOpenFileAppend(zone_source_path);
    if (!zone_source)
    {
        Com_Printf(CON_CHANNEL_FILES,"Can't save to zone source file '%s'.\n", zone_source_path);
        return;
    }
    
    FS_Printf(zone_source, "%s,%s\n", asset_type, asset_name);
    FS_FCloseFile(zone_source);
}

/* Extract rawfile. */
static void extract_rawfile(const void *header)
{
    char output_path[MAX_OSPATH];
    struct RawFile *asset = (struct RawFile *)header;
    fileHandle_t f;

    /* Do not extract with same name as .ff. */
    if (!strcmp(asset->name, g_zone_name))
    {
        Com_Printf(CON_CHANNEL_FILES,"ignored...");
        return;
    }

    snprintf(output_path, MAX_OSPATH, "%s%s/raw/%s", g_savePath, g_zone_name, asset->name);
    /* Mode must be "wb" because of \r\n doubling. */
    f = FS_SV_FOpenFileWrite(output_path);
    if (!f)
    {
        Com_Printf(CON_CHANNEL_FILES,"Can't open '%s': %s\n", output_path, strerror(errno));
        return;
    }
    WRITE_EXTRACTOR_HEADER(f);
    FS_Write(asset->buffer, asset->len, f);
    FS_FCloseFile(f);
    add_zone_source_line("rawfile", asset->name);
}

static void store_localized_string_file(const char *file_name)
{
    if (g_LocalizedStringFilesCount == MAX_LOCSTRING_FILES)
    {
        Com_Printf(CON_CHANNEL_FILES,"g_LocalizedStringFilesCount overflow. Increase MAX_LOCSTRING_FILES " \
                   "if you want to store more than %d localized string files.\n", MAX_LOCSTRING_FILES);
        return;
    }
    strncpy(g_LocalizedStringFiles[g_LocalizedStringFilesCount], file_name, MAX_OSPATH);
    ++g_LocalizedStringFilesCount;
}

static void add_endmarkers()
{
    uint i;
    fileHandle_t f;

    for (i = 0; i < g_LocalizedStringFilesCount; ++i)
    {
        f = FS_SV_FOpenFileAppend(g_LocalizedStringFiles[i]);
        if (f)
        {
            FS_Write("ENDMARKER\n", 10, f);
            FS_FCloseFile(f);
        }
    }
    g_LocalizedStringFilesCount = 0;
    memset(g_LocalizedStringFiles, 0, MAX_LOCSTRING_FILES*MAX_OSPATH);
}

static void replace_escape_characters(const char *in, char *out, uint out_size)
{
    char *ptr_in = (char*)in;
    char *ptr_out = out;
    uint i = 0;
    while(i <= out_size && *ptr_in)
    {
        if (*ptr_in == '\n')
        {
            *ptr_out = '\\';
            ++ptr_out;
            *ptr_out = 'n';
        }
        else if (*ptr_in == '\t')
        {
            *ptr_out = '\\';
            ++ptr_out;
            *ptr_out = 't';
        }
        else
            *ptr_out = *ptr_in;

        ++ptr_in;
        ++ptr_out;
        ++i;
    }
    *ptr_out = '\0';
    /* Oops, something has been left untouched. Need to increase buffer. */
    if (*ptr_in)
        Com_Printf(CON_CHANNEL_FILES,"Out buffer overflow. Increase size by %d bytes to get all data parsed...", strlen(ptr_in));
}

/* Extract localized string. */
static void extract_localized_string(const void *header)
{
    char output_path[MAX_OSPATH];
    char prefix[64] = {'\0'};
    LocalizedString_t *asset = (LocalizedString_t *)header;
    char *prefix_end;
    fileHandle_t f;
    char value_buf[1024] = {'\0'};

    /* Will be always because prefix is a file name. */
    prefix_end = strchr(asset->key, '_');
    if (prefix_end - asset->key + 1 > sizeof(prefix))
    {
        Com_Printf(CON_CHANNEL_FILES,"Too long prefix for localized string '%s'. Increase prefix size (now %d).\n", asset->key, sizeof(prefix));
        return;
    }
    strncpy(prefix, asset->key, prefix_end - asset->key);
    /* Build output file path. */
    snprintf(output_path, MAX_OSPATH, "%s%s/raw/english/localizedstrings/%s.str", g_savePath, g_zone_name, prefix);
    /* Check if file already exist. */
    if (!FS_SV_FOpenFileRead(output_path, &f))
    {
        /* File not exist -> add default header. */
        f = FS_SV_FOpenFileWrite(output_path);
        if (!f)
        {
            Com_Printf(CON_CHANNEL_FILES,"Can't open '%s'.\n", output_path);
            return;
        }
        WRITE_EXTRACTOR_HEADER(f);
        FS_Write("VERSION             \"1\"\n", 24, f);
        FS_Write("CONFIG              \"C:\\trees\\cod3\\cod3\\bin\\StringEd.cfg\"\n", 58, f);
        FS_Write("FILENOTES           \"Extracted from fastfile.\"\n\n", 48, f);
        add_zone_source_line("localize", prefix);
        store_localized_string_file(output_path);
    }
    else
    {
        FS_FCloseFile(f);
        f = FS_SV_FOpenFileAppend(output_path);
    }

    FS_Printf(f, "REFERENCE           %s\n", asset->key);
    replace_escape_characters(asset->value, value_buf, sizeof(value_buf));
    FS_Printf(f, "LANG_ENGLISH        \"%s\"\n\n", value_buf);
    FS_FCloseFile(f);
}

/* Extract string table. */
static void extract_stringtable(const void *header)
{
    StringTable_t *asset = (StringTable_t *)header;
    char output_path[MAX_OSPATH];
    fileHandle_t f;
    uint i;
    uint j;

    snprintf(output_path, MAX_OSPATH, "%s%s/raw/%s", g_savePath, g_zone_name, asset->name);
    f = FS_SV_FOpenFileWrite(output_path);
    if (!f)
    {
        Com_Printf(CON_CHANNEL_FILES,"Can't open '%s'.\n", output_path);
        return;
    }
    /* Write out string table. */
    for (i = 0; i < asset->rows; ++i)
    {
        for (j = 0; j < asset->columns; ++j)
        {
            /* Differ last column. */
            if (j != asset->columns - 1)
                FS_Printf(f, "%s,", asset->data[i * asset->columns + j]);
            else
                FS_Printf(f, "%s\n", asset->data[i * asset->columns + j]);
        }
    }
    FS_FCloseFile(f);
    add_zone_source_line("stringtable", asset->name);
}

/* Generates expression string for statement. */
static const char *generate_expression_string(const Statement_t *s)
{
    uint i;
    int j;
    ExpressionEntry_t *entry;
    Operand_t *operand;
    static char expression[2048];
    char *ptr = expression;
    int parensCount = 0;

    memset(expression, ' ', 2048);
    expression[2048 - 1] = '\0';
    /* Parse each entry. (expect first - '(') */
    for (i = 0; i < s->entries_count; ++i)
    {
        entry = s->entries[i];
        if (entry->type == ENTRYTYPE_OPERATION) /* 0 */
        {
            /* Operation, paren or function. */
            ptr += sprintf(ptr, "%s ", g_MenuOperations[entry->data.operation]);
        }
        else if (entry->type == ENTRYTYPE_OPERAND)
        {
            /* Integer, float or string. */
            operand = &entry->data.operand;
            if (operand->type == OPERANDTYPE_INTEGER)
                ptr += sprintf(ptr, "%d ", operand->data.i);
            else if (operand->type == OPERANDTYPE_FLOAT)
                ptr += sprintf(ptr, "%g ", operand->data.f);
            else if (operand->type == OPERANDTYPE_STRING)
                if (operand->data.s)
                    ptr += sprintf(ptr, "\"%s\" ", operand->data.s);
        }
    }
    *ptr = '\0';

    /* Recheck parens. */
    ptr = expression;
    while (*ptr)
    {
        if (*ptr == '(')
            ++parensCount;
        else if (*ptr == ')')
            --parensCount;

        ++ptr;
    }
    /* Should not be negative, but show warning. */
    if (parensCount < 0)
        Com_Printf(CON_CHANNEL_FILES,"Warning: more right parens than left parens.\n");
    else
    {
        /* Write missing right parens. */
        for (j = 0; j < parensCount; ++j)
        {
            ptr[0] = ')';
            ptr[1] = '\0';
            ++ptr;
        }
    }
    return expression;
}

/* Remove quotes from action string so interpreter will correctly parse its content. */
/* No null arg check but guaranteed to be called when action != 0. */
static const char *action_optimize(const char *action)
{
    static char res[ACTION_OPTIMIZER_BUFFER_SIZE];
    char ca[ACTION_OPTIMIZER_BUFFER_SIZE] = {'\0'};
    char *iter;
    char *start;
    int start_len;
    char *wIter;
    char can_remove = 1;
    char block_end = 0;

    /* Check for buffer overflow. */
    if (strlen(action) >= ACTION_OPTIMIZER_BUFFER_SIZE)
    {
        Com_Printf(CON_CHANNEL_FILES,"Buffer overflow detected (%d bytes). Increase ACTION_OPTIMIZER_BUFFER_SIZE.", strlen(action));
        return action;
    }

    /* Zero buffer. */
    memset(res, 0, ACTION_OPTIMIZER_BUFFER_SIZE);

    /* Copy string to first buffer so we can edit it. */
    strcpy(ca, action);
    ca[ACTION_OPTIMIZER_BUFFER_SIZE - 1] = '\0';
    
    /* Split input action by "<sometext>" or <text> blocks. */
    iter = ca;
    while (*iter)
    {
        /* Find begin of block. */
        while(*iter == ' ')
            ++iter;
        
        start = iter;
        ++iter;

        /* If block started with '\"' then must be ended with '\"'. */
        if (start[0] == '\"')
        {
            block_end = '\"';
            can_remove = 1;
        }
        else
        {
            block_end = ' ';
            can_remove = 0;
        }
        
        /* Find end of block. */
        while (*iter && *iter != block_end)
            ++iter;

        if (block_end == '\"')
            ++iter;
        *iter = '\0';

        /* Start now points to one block. */
        start_len = strlen(start);

        /* Confirm if we can remove quotes. */
        wIter = start;
        while(*wIter && can_remove)
        {
            /* Found space character? Sad but leave string as is. */
            if (*wIter == ' ')
                can_remove = 0;
            ++wIter;
        }
        /* Copy block to without\with quotes to other buffer. */
        if (can_remove)
            strncat(res, start + 1, start_len - 2);
        else
            strncat(res, start, start_len);

        strcat(res, " ");
        ++iter;
    }
    return res;
}

#define MENUDEF_INDENT "        "
#define ITEMDEF_INDENT "            "
#define MENU_KEY_INDENT "%-25s "
/* MenuDef_t fields. */
#define WRITE_MENU_FIELD(indent, args_format, ...) \
    FS_Printf(f, indent MENU_KEY_INDENT args_format "\n", __VA_ARGS__)


#define WRITE_MENU_FIELD_COND(condition, indent, args_format, ...) \
    do { \
        if ((condition)) \
            WRITE_MENU_FIELD(indent, args_format, __VA_ARGS__); \
    } while(0)


#define WRITE_MENUDEF_FIELD_FLAG(str_key, int_condition) \
    WRITE_MENU_FIELD_COND( \
        (int_condition), \
        MENUDEF_INDENT, \
        "", \
        (str_key) \
    )


#define WRITE_MENUDEF_FIELD_EXPRESSION(str_key, expression) WRITE_MENU_FIELD_COND( (expression).entries_count, MENUDEF_INDENT, "%s ( %s );", \
        "exp", \
        (str_key), \
        generate_expression_string(&(expression)) \
    )

#define WRITE_MENUDEF_FIELD_VISIBLE(expression) \
    do { \
        if ((expression).entries_count) \
            WRITE_MENU_FIELD(MENUDEF_INDENT, "when ( %s )", "visible", generate_expression_string(&(expression))); \
        else \
            WRITE_MENU_FIELD(MENUDEF_INDENT, "", "visible 0"); \
    }while(0)

#define WRITE_MENUDEF_FIELD_KEY(key_hndl) WRITE_MENU_FIELD_COND( (key_hndl), MENUDEF_INDENT, "\"%c\" { %s }", \
        "execKey", (key_hndl)->key, action_optimize((key_hndl)->action) \
    )


#define WRITE_MENUDEF_FIELD_VEC4(str_key, vec4_val) \
    WRITE_MENU_FIELD_COND( \
        1, \
        MENUDEF_INDENT, \
        "%g %g %g %g", \
        (str_key), \
        (vec4_val)[0], (vec4_val)[1], (vec4_val)[2], (vec4_val)[3] \
    )

#define WRITE_MENUDEF_FIELD_RECT(str_key, rect_val) \
    WRITE_MENU_FIELD_COND( \
        ((rect_val).x || (rect_val).y || (rect_val).w || (rect_val).h || (rect_val).horzAlign || (rect_val).vertAlign), \
        MENUDEF_INDENT, \
        "%g %g %g %g %s %s", \
        (str_key), \
        (rect_val).x, (rect_val).y, (rect_val).w, (rect_val).h, \
        find_word(g_RectAlignHorizontal, (rect_val).horzAlign), find_word(g_RectAlignVertical, (rect_val).vertAlign) \
    )

#define WRITE_MENUDEF_FIELD_ACTION(str_key, str_action) WRITE_MENU_FIELD_COND( (str_action), MENUDEF_INDENT, "{ %s }", \
        (str_key), action_optimize((str_action)) \
    )

#define WRITE_MENUDEF_FIELD_MATERIAL(str_key, mtl) \
    WRITE_MENU_FIELD_COND( \
        (mtl), \
        MENUDEF_INDENT, \
        "\"%s\"", \
        (str_key), \
        *(mtl) \
    )

#define WRITE_MENUDEF_FIELD_STRING(str_key, str_val) \
    WRITE_MENU_FIELD_COND( \
        (str_val), \
        MENUDEF_INDENT, \
        "\"%s\"", \
        (str_key), \
        (str_val) \
    )

#define WRITE_MENUDEF_FIELD_KEYWORD(str_key, ptr_keyword, int_val) \
    WRITE_MENU_FIELD_COND( \
        (int_val), \
        MENUDEF_INDENT, \
        "%s", \
        (str_key), \
        find_word((ptr_keyword), (int_val)) \
    )

#define WRITE_MENUDEF_FIELD_FLOAT(str_key, float_val) \
    WRITE_MENU_FIELD_COND( \
        (float_val) != 0, \
        MENUDEF_INDENT, \
        "%g", \
        (str_key), \
        (float_val) \
    )


#define WRITE_MENUDEF_FIELD_INT(str_key, int_val) \
    WRITE_MENU_FIELD_COND( \
        (int_val), \
        MENUDEF_INDENT, \
        "%d", \
        (str_key), \
        (int_val) \
    )


/* ItemDef_t fields. */
#define WRITE_ITEMDEF_FIELD_FLAG(str_key, int_condition) \
    WRITE_MENU_FIELD_COND( \
        (int_condition), \
        ITEMDEF_INDENT, \
        "", \
        (str_key) \
    )


#define WRITE_ITEMDEF_FIELD_EXPRESSION(str_key, expression) WRITE_MENU_FIELD_COND( (expression).entries_count, ITEMDEF_INDENT, "%s ( %s );", \
        "exp", (str_key), generate_expression_string(&(expression)) \
    )

#define WRITE_ITEMDEF_FIELD_VISIBLE(expression) \
    do { \
        if ((expression).entries_count) \
            WRITE_MENU_FIELD(ITEMDEF_INDENT, "when ( %s )", "visible", generate_expression_string(&(expression))); \
        else \
            WRITE_MENU_FIELD(ITEMDEF_INDENT, "", "visible 1"); \
    }while(0)


#define WRITE_ITEMDEF_FIELD_KEY(key_hndl) WRITE_MENU_FIELD_COND( (key_hndl), ITEMDEF_INDENT, "\"%c\" { %s }", \
        "execKey", (key_hndl)->key, action_optimize((key_hndl)->action) \
    )


#define WRITE_ITEMDEF_FIELD_VEC4(str_key, vec4_val) \
    WRITE_MENU_FIELD_COND( \
        1, \
        ITEMDEF_INDENT, \
        "%g %g %g %g", \
        (str_key), \
        (vec4_val)[0], (vec4_val)[1], (vec4_val)[2], (vec4_val)[3] \
    )


#define WRITE_ITEMDEF_FIELD_RECT(str_key, rect_val) \
    WRITE_MENU_FIELD_COND( \
        ((rect_val).x || (rect_val).y || (rect_val).w || (rect_val).h || (rect_val).horzAlign || (rect_val).vertAlign), \
        ITEMDEF_INDENT, \
        "%g %g %g %g %s %s", \
        (str_key), \
        (rect_val).x, (rect_val).y, (rect_val).w, (rect_val).h, \
        find_word(g_RectAlignHorizontal, (rect_val).horzAlign), find_word(g_RectAlignVertical, (rect_val).vertAlign) \
    )


#define WRITE_ITEMDEF_FIELD_ACTION(str_key, str_action) WRITE_MENU_FIELD_COND( (str_action), ITEMDEF_INDENT, "{ %s }", \
        (str_key), action_optimize((str_action)) \
    )


#define WRITE_ITEMDEF_FIELD_MATERIAL(str_key, mtl) \
    WRITE_MENU_FIELD_COND( \
        (mtl), \
        ITEMDEF_INDENT, \
        "\"%s\"", \
        (str_key), \
        *(mtl) \
    )


#define WRITE_ITEMDEF_FIELD_STRING(str_key, str_val) \
    WRITE_MENU_FIELD_COND( \
        (str_val), \
        ITEMDEF_INDENT, \
        "\"%s\"", \
        (str_key), \
        (str_val) \
    )

#define WRITE_ITEMDEF_FIELD_KEYWORD(str_key, ptr_keyword, int_val) \
    WRITE_MENU_FIELD_COND( \
        (int_val), \
        ITEMDEF_INDENT, \
        "%s", \
        (str_key), \
        find_word((ptr_keyword), (int_val)) \
    )

#define WRITE_ITEMDEF_FIELD_FLOAT(str_key, float_val) \
    WRITE_MENU_FIELD_COND( \
        (float_val) != 0, \
        ITEMDEF_INDENT, \
        "%g", \
        (str_key), \
        (float_val) \
    )


#define WRITE_ITEMDEF_FIELD_INT(str_key, int_val) \
    WRITE_MENU_FIELD_COND( \
        (int_val), \
        ITEMDEF_INDENT, \
        "%d", \
        (str_key), \
        (int_val) \
    )

/* Write window properties to file. */
/* Some of WindowDef_t fields are not required for MenuDef_t. */
static void extract_menu_window(fileHandle_t f, const WindowDef_t *w)
{
    /* Ignored for menu: origin, group. */
    WRITE_MENUDEF_FIELD_STRING("name", w->name);
    WRITE_MENUDEF_FIELD_RECT("rect", w->rect);
    WRITE_MENUDEF_FIELD_KEYWORD("style", g_WindowStyle, w->style);
    WRITE_MENUDEF_FIELD_KEYWORD("border", g_WindowBorderType, w->border);
    WRITE_MENUDEF_FIELD_KEYWORD("ownerDraw", g_WindowOwnerdrawType, w->ownerDraw);
    WRITE_MENUDEF_FIELD_INT("ownerDrawFlag", w->ownerDrawFlag);
    WRITE_MENUDEF_FIELD_FLOAT("borderSize", w->borderSize);
    WRITE_MENUDEF_FIELD_VEC4("foreColor", w->foreColor);
    WRITE_MENUDEF_FIELD_VEC4("backColor", w->backColor);
    WRITE_MENUDEF_FIELD_VEC4("borderColor", w->borderColor);
    WRITE_MENUDEF_FIELD_VEC4("outlineColor", w->outlineColor);
    WRITE_MENUDEF_FIELD_MATERIAL("background", ((char**)w->background));
}

/* Write MenuDef_t properties. */
static void extract_menu_fields(fileHandle_t f, const MenuDef_t *m)
{
    ItemKeyHandler_t *key = m->onKey;
    extract_menu_window(f, &m->window);    
    WRITE_MENUDEF_FIELD_INT("fullScreen", m->fullScreen);
    WRITE_MENUDEF_FIELD_INT("fadeCycle", m->fadeCycle);
    WRITE_MENUDEF_FIELD_FLOAT("fadeClamp", m->fadeClamp);
    WRITE_MENUDEF_FIELD_FLOAT("fadeAmount", m->fadeAmount);
    WRITE_MENUDEF_FIELD_FLOAT("fadeInAmount", m->fadeInAmount);
    WRITE_MENUDEF_FIELD_FLOAT("blurWorld", m->blurWorld);
    WRITE_MENUDEF_FIELD_ACTION("onOpen", m->onOpen);
    WRITE_MENUDEF_FIELD_ACTION("onClose", m->onClose);
    WRITE_MENUDEF_FIELD_ACTION("onESC", m->onESC);
    while (key)
    {
        WRITE_MENUDEF_FIELD_KEY(key);
        key = key->next;
    }
    
    WRITE_MENUDEF_FIELD_STRING("allowedBinding", m->allowedBinding);
    WRITE_MENUDEF_FIELD_STRING("soundLoop", m->soundLoop);
    WRITE_MENUDEF_FIELD_VEC4("focusColor", m->focusColor);
    WRITE_MENUDEF_FIELD_VEC4("disableColor", m->disableColor);
    WRITE_MENUDEF_FIELD_FLAG("outofboundsclick", m->window.staticFlags & WINDOW_FLAG_OUTOFBOUNDSCLICK);
    WRITE_MENUDEF_FIELD_FLAG("popup", m->window.staticFlags & WINDOW_FLAG_POPUP);
    WRITE_MENUDEF_FIELD_FLAG("legacysplitscreenscale", m->window.staticFlags & WINDOW_FLAG_LEGACYSPLITSCREENSCALE);
    WRITE_MENUDEF_FIELD_FLAG("hiddenduringscope", m->window.staticFlags & WINDOW_FLAG_HIDDENDURINGSCOPE);
    WRITE_MENUDEF_FIELD_FLAG("hiddenduringflashbang", m->window.staticFlags & WINDOW_FLAG_HIDDENDURINGFLASHBANG);
    WRITE_MENUDEF_FIELD_FLAG("hiddenduringui", m->window.staticFlags & WINDOW_FLAG_HIDDENDURINGUI);
    WRITE_MENUDEF_FIELD_EXPRESSION("rect X", m->rectXExp);
    WRITE_MENUDEF_FIELD_EXPRESSION("rect Y", m->rectYExp);
    WRITE_MENUDEF_FIELD_VISIBLE(m->visibleExp);
}

/* Extract ItemDef's window properties. */
static void extract_menu_item_window(fileHandle_t f, const WindowDef_t *w)
{
    /* Ignored: origin. */
    WRITE_ITEMDEF_FIELD_STRING("name", w->name);
    /* For ItemDef we don't need full RECT values. */
    WRITE_ITEMDEF_FIELD_RECT("rect", w->rectClient);
    WRITE_ITEMDEF_FIELD_STRING("group", w->group);
    WRITE_ITEMDEF_FIELD_KEYWORD("style", g_WindowStyle, w->style);
    WRITE_ITEMDEF_FIELD_KEYWORD("border", g_WindowBorderType, w->border);
    WRITE_ITEMDEF_FIELD_KEYWORD("ownerDraw", g_WindowOwnerdrawType, w->ownerDraw);
    WRITE_ITEMDEF_FIELD_INT("ownerDrawFlag", w->ownerDrawFlag);
    WRITE_ITEMDEF_FIELD_FLOAT("borderSize", w->borderSize);
    WRITE_ITEMDEF_FIELD_VEC4("foreColor", w->foreColor);
    WRITE_ITEMDEF_FIELD_VEC4("backColor", w->backColor);
    WRITE_ITEMDEF_FIELD_VEC4("borderColor", w->borderColor);
    WRITE_ITEMDEF_FIELD_VEC4("outlineColor", w->outlineColor);
    WRITE_ITEMDEF_FIELD_MATERIAL("background", ((char**)w->background));
}

/* Extract ItemDef's list box properties. */
static void extract_menu_item_listbox(fileHandle_t f, const ListBoxDef_t *lb)
{
    uint i;
    WRITE_ITEMDEF_FIELD_FLOAT("elementWidth", lb->elementWidth);
    WRITE_ITEMDEF_FIELD_FLOAT("elementHeight", lb->elementHeight);
    WRITE_ITEMDEF_FIELD_KEYWORD("elementType", g_ListBoxElementType, lb->elementType);
    /* Columns output. Not sure if ColumnInfo_t.alignment in use. */
    if (lb->columns_count)
    {
        FS_Printf(f, ITEMDEF_INDENT"columns %2d %4d %4d %3d\n", lb->columns_count, lb->columns[0].xpos, lb->columns[0].xwidth, lb->columns[0].textLen);
        for (i = 1; i < lb->columns_count; ++i)
            FS_Printf(f, ITEMDEF_INDENT"           %4d %4d %3d\n", lb->columns[i].xpos, lb->columns[i].xwidth, lb->columns[i].textLen);
    }
    WRITE_ITEMDEF_FIELD_STRING("doubleClick", lb->doubleClick);
    WRITE_ITEMDEF_FIELD_VEC4("selectBorder", lb->selectBorder);
    WRITE_ITEMDEF_FIELD_VEC4("disableColor", lb->disableColor);
    WRITE_ITEMDEF_FIELD_MATERIAL("selectIcon", (char**)lb->selectIcon);
    WRITE_ITEMDEF_FIELD_FLAG("notSelectable", lb->notSelectable);
    WRITE_ITEMDEF_FIELD_FLAG("noScrollBars", lb->noScrollBars);
    WRITE_ITEMDEF_FIELD_FLAG("usePaging", lb->usePaging);
}

/* Extract ItemDef's edit field properties. */
static void extract_menu_item_editfield(fileHandle_t f, const EditFieldDef_t *ef)
{
    WRITE_ITEMDEF_FIELD_INT("maxChars", ef->maxChars);
    WRITE_ITEMDEF_FIELD_INT("maxPaintChars", ef->maxPaintChars);
    WRITE_ITEMDEF_FIELD_FLAG("maxCharsGotoNext", ef->maxCharsGotoNext);
}

/* Extract ItemDef's multilist properties. */
static void extract_menu_item_multi(fileHandle_t f, const ItemDefData_t *idd)
{
    uint i;
    char *list_type = "dvarFloatList";
    if (idd->multi->isStrList == 1)
        list_type = "dvarStrList";
    
    if (idd->multi->count)
    {
        FS_Printf(f, ITEMDEF_INDENT MENU_KEY_INDENT "{ ", list_type);
        for (i = 0; i < idd->multi->count; ++i)
        {
            if (idd->multi->isStrList == 1)
                FS_Printf(f, "\"%s\", \"%s\"; ", idd->multi->stringValue[i], idd->multi->onDvarString[i]);
            else
                FS_Printf(f, "\"%s\" %g ", idd->multi->stringValue[i], idd->multi->onDvarFloat[i]);
        }
        FS_Printf(f, " }\n");
    }
}

/* Extract ItemDef's dvarenum properties. */
/* TODO. rework */
static void extract_menu_item_dvarenum(fileHandle_t f, const ItemDefData_t *idd)
{
    WRITE_MENU_FIELD_COND(idd->multi->count, ITEMDEF_INDENT, "%s", "dvarEnumList", idd->enumDvarName);
    return;
}

static int is_editField_item(const ItemDef_t *i)
{
    switch ( i->type )
    {
        case ITEM_TYPE_TEXT:
        case ITEM_TYPE_EDITFIELD:
        case ITEM_TYPE_NUMERICFIELD:
        case ITEM_TYPE_SLIDER:
        case ITEM_TYPE_YESNO:
        case ITEM_TYPE_BIND:
        case ITEM_TYPE_VALIDFILEFIELD:
        case ITEM_TYPE_DECIMALFIELD:
        case ITEM_TYPE_UPREDITFIELD:
            return 1;
        default:
            return 0;
    }
    return 0;
}

/* Extract ItemDef_t prorerties. */
static void extract_menu_item(fileHandle_t f, const ItemDef_t *i)
{
    ItemKeyHandler_t *key = i->onKey;
    char *onDvarString;
    extract_menu_item_window(f, &i->window);
    /* i->textRect. What is it. I can't remember but I know there's a way to move text within itemdef. */
    WRITE_ITEMDEF_FIELD_KEYWORD("type", g_ItemType, i->type);
    /* i->dataType - same as type. Shouldn't be extracted here? */
    WRITE_ITEMDEF_FIELD_KEYWORD("align", g_ItemAlign, i->align);
    WRITE_ITEMDEF_FIELD_KEYWORD("textFont", g_ItemFontType, i->textFont);
    WRITE_ITEMDEF_FIELD_KEYWORD("textAlign", g_ItemAlign, i->textAlign);
    WRITE_ITEMDEF_FIELD_FLOAT("textAlignX", i->textAlignX);
    WRITE_ITEMDEF_FIELD_FLOAT("textAlignY", i->textAlignY);
    WRITE_ITEMDEF_FIELD_FLOAT("textScale", i->textScale);
    WRITE_ITEMDEF_FIELD_KEYWORD("textStyle", g_ItemTextStyle, i->textStyle);
    WRITE_ITEMDEF_FIELD_INT("gameMsgWindowIndex", i->gameMsgWindowIndex);
    WRITE_ITEMDEF_FIELD_KEYWORD("gameMsgWindowMode", g_ItemMSGWindowMode, i->gameMsgWindowMode);
    WRITE_ITEMDEF_FIELD_STRING("text", i->text);
    WRITE_ITEMDEF_FIELD_INT("textSavegame", i->textSavegame);
    WRITE_ITEMDEF_FIELD_STRING("mouseEnterText", i->mouseEnterText);
    WRITE_ITEMDEF_FIELD_STRING("mouseExitText", i->mouseExitText);
    WRITE_ITEMDEF_FIELD_ACTION("mouseEnter", i->mouseEnter);
    WRITE_ITEMDEF_FIELD_ACTION("mouseExit", i->mouseExit);
    WRITE_ITEMDEF_FIELD_ACTION("action", i->action);
    WRITE_ITEMDEF_FIELD_ACTION("accept", i->accept);
    WRITE_ITEMDEF_FIELD_ACTION("onFocus", i->onFocus);
    WRITE_ITEMDEF_FIELD_ACTION("leaveFocus", i->leaveFocus);
    if (i->dvar && is_editField_item(i))
    {
        WRITE_MENU_FIELD(ITEMDEF_INDENT, "\"%s\" %g %g %g", "dvarFloat", i->dvar, i->typeData.editField->defVal, i->typeData.editField->minVal, i->typeData.editField->maxVal);
    }
    else
    {
        WRITE_ITEMDEF_FIELD_STRING("dvar", i->dvar);
    }
    WRITE_ITEMDEF_FIELD_STRING("dvarTest", i->dvarTest);
    while (key)
    {
        WRITE_ITEMDEF_FIELD_KEY(key);
        key = key->next;
    }
    onDvarString = "enableDvar";
    if (i->dvarFlags & DVAR_FLAG_DISABLEDVAR)
        onDvarString = "disableDvar";
    else if (i->dvarFlags & DVAR_FLAG_SHOWDVAR)
        onDvarString = "showDvar";
    else if (i->dvarFlags & DVAR_FLAG_HIDEDVAR)
        onDvarString = "hideDvar";
    else if (i->dvarFlags & DVAR_FLAG_FOCUSDVAR)
        onDvarString = "focusDvar";
    WRITE_ITEMDEF_FIELD_ACTION(onDvarString, i->onDvar);

    /* TODO_later: ItemDef_t.focusSound was not used. */
    WRITE_ITEMDEF_FIELD_KEYWORD("feeder", g_ListBoxFeeder, i->feeder);
    
    if (i->type == ITEM_TYPE_LISTBOX)
        extract_menu_item_listbox(f, i->typeData.listBox);
    else if (i->type == ITEM_TYPE_EDITFIELD)
        extract_menu_item_editfield(f, i->typeData.editField);
    else if (i->type == ITEM_TYPE_MULTI)
        extract_menu_item_multi(f, &i->typeData);
    else if (i->type == ITEM_TYPE_DVARENUM)
        extract_menu_item_dvarenum(f, &i->typeData);
    
    WRITE_ITEMDEF_FIELD_EXPRESSION("text", i->textExp);
    WRITE_ITEMDEF_FIELD_EXPRESSION("material", i->materialExp);
    WRITE_ITEMDEF_FIELD_EXPRESSION("rect X", i->rectXExp);
    WRITE_ITEMDEF_FIELD_EXPRESSION("rect Y", i->rectYExp);
    WRITE_ITEMDEF_FIELD_EXPRESSION("rect W", i->rectWExp);
    WRITE_ITEMDEF_FIELD_EXPRESSION("rect H", i->rectHExp);
    WRITE_ITEMDEF_FIELD_EXPRESSION("foreColor A", i->foreColorAExp);
    WRITE_ITEMDEF_FIELD_VISIBLE(i->visibleExp);
    WRITE_ITEMDEF_FIELD_FLAG("decoration", i->window.staticFlags & WINDOW_FLAG_DECORATION);
    WRITE_ITEMDEF_FIELD_FLAG("autoWrapped", i->window.staticFlags & WINDOW_FLAG_AUTOWRAPPED);
    WRITE_ITEMDEF_FIELD_FLAG("horizontalScroll", i->window.staticFlags & WINDOW_FLAG_HORIZONTALSCROLL);
}

/* Extract single menu. Must be used only inside 'extract_menufile' */
static void extract_menu(fileHandle_t f, MenuDef_t *asset)
{
    int i;
    Com_Printf(CON_CHANNEL_FILES,"    Writing menu '%s'...", asset->window.name);

    /* Write menudef header. */
    FS_Write("    menuDef\n    {\n", 18, f);
    /* Write menudef fields. */
    extract_menu_fields(f, asset);
    /* Write all menu items. */
    for (i = 0; i < asset->itemCount; ++i)
    {
        /* Write itemdef header. */
        FS_Write("        itemDef\n        {\n", 26, f);
        /* Write itemdef fields. */
        extract_menu_item(f, asset->items[i]);
        /* Write itemdef footer. */
        FS_Write("        }\n", 10, f);
    }
    /* Write menudef footer. */
    FS_Write("    }\n", 6, f);

    Com_Printf(CON_CHANNEL_FILES,"done.\n");
}

/* Extract menufile. */
static void extract_menufile(const void *header)
{
    Menufile_t *asset = (Menufile_t *)header;
    char subpath[128] = {'\0'};
    fileHandle_t text_menufile;
    fileHandle_t f;
    char text_asset_name[MAX_OSPATH] = {'\0'};
    char output_path[MAX_OSPATH];
    uint i;

    strcpy(subpath, Sys_Dirname(asset->name));
    /* Newline for each menu. */
    Com_Printf(CON_CHANNEL_FILES,"\n");
    if (!strstr(asset->name, ".txt"))
    {
        snprintf(output_path, MAX_OSPATH, "%s%s/raw/%s", g_savePath, g_zone_name, asset->name);
        f = FS_SV_FOpenFileWrite(output_path);
        if (!f)
        {
            Com_Printf(CON_CHANNEL_FILES,"Can't open '%s'.\n", output_path);
            return;
        }
         /* Write .menu file header. */
        WRITE_EXTRACTOR_HEADER(f);
        FS_Write("#include \"ui/menudefinition.h\";\n{\n", 34, f);
        /* Extract .menu content. */
        for (i = 0; i < asset->count; ++i)
            extract_menu(f, asset->menus[i]);

        /* Write .menu file footer. */
        FS_Write("}\n", 2, f);
        FS_FCloseFile(f);
        add_zone_source_line("menufile", asset->name);
    }
    else
    {
        /* Generate .txt name for asset. */
        snprintf(text_asset_name, MAX_OSPATH, "%s%s/raw/%s", g_savePath, g_zone_name, asset->name);
        text_menufile = FS_SV_FOpenFileWrite(text_asset_name);
        if (!text_menufile)
        {
            Com_Printf(CON_CHANNEL_FILES,"Can't open '%s'.\n", text_asset_name);
            return;
        }
        /* Write header to .txt file. */
        
        FS_Write("{\n", 2, text_menufile);
        /* Write each menu and add it to .txt menufile. */
        for (i = 0; i < asset->count; ++i)
        {
            
            snprintf(output_path, MAX_OSPATH, "%s%s/raw/%s/%s.menu", g_savePath, g_zone_name, subpath, asset->menus[i]->window.name);
            f = FS_SV_FOpenFileWrite(output_path);
            if (!f)
            {
                Com_Printf(CON_CHANNEL_FILES,"Can't open '%s'.\n", output_path);
                return;
            }
            /* Write .menu file header. */
            WRITE_EXTRACTOR_HEADER(f);
            FS_Write("#include \"ui/menudefinition.h\";\n{\n", 34, f);
            /* Extract .menu content. */
            extract_menu(f, asset->menus[i]);
            /* Write .menu file footer. */
            FS_Write("}\n", 2, f);
            FS_FCloseFile(f);
            FS_Printf(text_menufile, "    loadMenu { \"%s/%s.menu\" }\n", subpath, asset->menus[i]->window.name);
        }
        /* Write footer to .txt file. */
        FS_Write("}\n", 2, text_menufile);
        FS_FCloseFile(text_menufile);
        /* Add .txt menufile to zone_source file. */
        add_zone_source_line("menufile", asset->name);
    }
}

/* Extract all assets from fastfile. */
static void extract_from_fastfile(const FastFileAssetsTableInfo_t *ff_info, const unsigned int type, extract_routine_t handler)
{
    int i;
    for (i = 0; i < ff_info->content.asset_list_count; ++i)
    {
        if (ff_info->content.asset_list_data[i].type == type)
        {
            Com_Printf(CON_CHANNEL_FILES,"Extracting '%s'...", DB_XAssetGetName(&ff_info->content.asset_list_data[i]));
            handler(ff_info->content.asset_list_data[i].header);
            Com_Printf(CON_CHANNEL_FILES,"done.\n");
        }
    }
    /* Post-extraction actions. */
    /* For localized strings add 'ENDMARKER' keyword to the end of files. */
    if (type == XASSET_TYPE_LOCALIZEDSTRING)
        add_endmarkers();
}

/* Console command used to extrate different types of assets from different loaded fastfiles. */
void Cmd_ExtractAsset()
{
    char *type;
    int type_num = -1;
    FastFileAssetsTableInfo_t *ff_info = 0;
    extract_routine_t handler = 0;
    int i;

    if (Cmd_Argc() != 3)
    {
    USAGE:
        Com_Printf(CON_CHANNEL_FILES,"Usage:\n");
        Com_Printf(CON_CHANNEL_FILES,"Server must be running in order to extract assets.\n");
        Com_Printf(CON_CHANNEL_FILES,"  %s <ff> <type>\n", Cmd_Argv(0));
        Com_Printf(CON_CHANNEL_FILES,"    ff - Name of fastfile to look into, without extension.\n");
        Com_Printf(CON_CHANNEL_FILES,"    type - Type of asset. Must be one of:\n");
        Com_Printf(CON_CHANNEL_FILES,"           all\n");
        for (i = 0; i < 33; ++i)
        {
            if (g_ExtractorRoutines[i].handler)
                Com_Printf(CON_CHANNEL_FILES,"           %s\n", g_ExtractorRoutines[i].name);
        }
        return;
    }

    if (!com_sv_running->boolean)
    {
        goto USAGE;
    }

    /* Find FastFile info. */
    g_zone_name = Cmd_Argv(1);
    for (i = 0; i < MAX_STORE_FASTFILES; ++i)
    {
        if (!strcmp(g_zone_name, g_FastFileAssetsTableInfo[i].name))
            ff_info = &g_FastFileAssetsTableInfo[i];
    }
    if (!ff_info)
    {
        Com_Printf(CON_CHANNEL_FILES,"Fastfile with name '%s' not loaded.\n", g_zone_name);
        return;
    }

    /* Get extractor handler. */
    type = Cmd_Argv(2);
    /* First check if all assets requested. */
    if (!strcmp(type, "all"))
    {
        Com_Printf(CON_CHANNEL_FILES,"Output directory: '%s%s/'\n", g_savePath, g_zone_name);
        /* Do all assets. */
        for (i = 0; i < 33; ++i)
        {
            /* Extract only if handler routine available. */
            if (g_ExtractorRoutines[i].handler)
            {
                Com_Printf(CON_CHANNEL_FILES,"\nExtracting assets of type '%s' from fastfile '%s':\n", g_ExtractorRoutines[i].name, g_zone_name);
                extract_from_fastfile(ff_info, g_ExtractorRoutines[i].type, g_ExtractorRoutines[i].handler);
            }
        }
        g_zone_name = 0;
        return;
    }
    /* Extract one type of assets otherwise. */
    for (i = 0; i < 33; ++i)
    {
        if (g_ExtractorRoutines[i].handler && !strcmp(type, g_ExtractorRoutines[i].name))
        {
            handler = g_ExtractorRoutines[i].handler;
            type_num = g_ExtractorRoutines[i].type;
            break;
        }
    }
    
    if (!handler || type_num == -1)
    {
        Com_Printf(CON_CHANNEL_FILES,"Unknown asset type '%s'.\n", type);
        goto USAGE;
    }
    /* Do one asset. */
    Com_Printf(CON_CHANNEL_FILES,"Output directory: './%s%s/'\n", g_savePath, g_zone_name);
    Com_Printf(CON_CHANNEL_FILES,"Extracting assets of type '%s' from fastfile '%s':\n", type, g_zone_name);    
    extract_from_fastfile(ff_info, type_num, handler);
    g_zone_name = 0;
}

#define g_AssetNames ((char**)0x08274940)

void Cmd_ListAssets()
{
    char *ff;
    FastFileContents_t *ff_contents = 0;
    int assets[33] = {0};
    int i;

    if (Cmd_Argc() != 2)
    {
        Com_Printf(CON_CHANNEL_FILES,"List contents of fastfile.\n");
        Com_Printf(CON_CHANNEL_FILES,"Map fastfiles are ignored for now.\n");
        Com_Printf(CON_CHANNEL_FILES,"Usage:\n");
        Com_Printf(CON_CHANNEL_FILES,"  %s <fastfile_name>\n", Cmd_Argv(0));
        return;
    }

    ff = Cmd_Argv(1);
    for (i = 0; i < MAX_STORE_FASTFILES; ++i)
    {
        if (!strcmp(ff, g_FastFileAssetsTableInfo[i].name))
            ff_contents = &g_FastFileAssetsTableInfo[i].content;
    }
    if (!ff_contents)
    {
        Com_Printf(CON_CHANNEL_FILES,"Fastfile with name '%s' not loaded.\n", ff);
        return;
    }

    for (i = 0; i < ff_contents->asset_list_count; ++i)
        ++assets[ff_contents->asset_list_data[i].type];

    Com_Printf(CON_CHANNEL_FILES,"Contents of fastfile '%s':\n", ff);
    for (i = 0; i < 33; ++i)
    {
        if (assets[i])
            Com_Printf(CON_CHANNEL_FILES,"Assets count for type '%s': %d\n", g_AssetNames[i], assets[i]);
    }
}

void add_extractor_console_commands()
{
    Cmd_AddCommand("extract", Cmd_ExtractAsset);
    Cmd_AddCommand("assets", Cmd_ListAssets);
}

/* Definitions cleanup. */
#undef g_AssetNames
#undef MENUDEF_INDENT
#undef ITEMDEF_INDENT
#undef MENU_KEY_INDENT
#undef WRITE_MENU_FIELD
#undef WRITE_MENU_FIELD_COND
#undef WRITE_MENUDEF_FIELD_FLAG
#undef WRITE_MENUDEF_FIELD_EXPRESSION
#undef WRITE_MENUDEF_FIELD_KEY
#undef WRITE_MENUDEF_FIELD_VEC4
#undef WRITE_MENUDEF_FIELD_RECT
#undef WRITE_MENUDEF_FIELD_ACTION
#undef WRITE_MENUDEF_FIELD_MATERIAL
#undef WRITE_MENUDEF_FIELD_STRING
#undef WRITE_MENUDEF_FIELD_FLOAT
#undef WRITE_MENUDEF_FIELD_INT
#undef WRITE_ITEMDEF_FIELD_FLAG
#undef WRITE_ITEMDEF_FIELD_EXPRESSION
#undef WRITE_ITEMDEF_FIELD_KEY
#undef WRITE_ITEMDEF_FIELD_VEC4
#undef WRITE_ITEMDEF_FIELD_RECT
#undef WRITE_ITEMDEF_FIELD_ACTION
#undef WRITE_ITEMDEF_FIELD_MATERIAL
#undef WRITE_ITEMDEF_FIELD_STRING
#undef WRITE_ITEMDEF_FIELD_FLOAT
#undef WRITE_ITEMDEF_FIELD_INT
#undef WRITE_EXTRACTOR_HEADER

#else

void extractor_init(){}
void add_extractor_console_commands(){}


#endif